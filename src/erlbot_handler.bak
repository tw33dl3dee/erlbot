
%%%-------------------------------------------------------------------
%%% Internal functions
%%%-------------------------------------------------------------------

%% update_stat(_, me, [User, Msg]) ->
%% 	update_stat(User, Msg);
%% update_stat(_, chanmsg, [User, Msg]) ->
%% 	update_stat(User, Msg);
%% update_stat(_, _, _) ->
%% 	ok.


%% update_history(Event, State) ->
%% 	io:format("Histent: ~p~n", [histent_to_list({Event})]),
%% 	Time = erlang:localtime(),
%% 	State#state{history = lists:sublist([{Time, Event} | State#state.history], ?MAX_HIST_LEN)}.

handle_chanevent({joined, Chan, Topic, Users}, #state{was_kicked = true, kicked_by = Kicker} = State) ->
	cmd({chanmsg, [suicide_greeting(State, Kicker)]}, State),
	become_op(State),
	State#state{was_kicked = false};

handle_chanevent({kicked, Chan, User, _Reason}, State) ->
	cmd({join, Chan}, State),
	State#state{was_kicked = true, kicked_by = User};

parse_cmd(State, User, ["stat"]) ->
	show_stat(State, User#user.ident);

parse_cmd(State, User, ["suicide", Delay]) ->
	case catch list_to_integer(Delay) of
		{'EXIT', _} -> 
			ok;
		X ->
			do_suicide(State, User#user.nick, X*1000)
	end;
parse_cmd(State, User, ["suicide"]) ->
	do_suicide(State, User#user.nick);


parse_privcmd(State, User, ["stat"]) ->
	show_stat(State, User#user.ident);

parse_privcmd(State, User, ["hist"]) ->
	show_history(State, User);

empty_err_msg(X) when X < 0.25 ->
	"А вот хуй...";
empty_err_msg(X) when X < 0.5 ->
	"<тут могла бы быть ваша реклама>";
empty_err_msg(X) when X < 0.75 ->
	"Да хер его знает.";
empty_err_msg(_) ->
	"Почувствуйте себя неудачником!".

print_long_results(State, [""]) ->
	cmd({chanmsg, [empty_err_msg(random_p:uniform())]}, State),
	ok;
print_long_results(State, Results) ->
	lists:foreach(fun (S) -> cmd({chanmsg, [S]), timer:sleep(?MSG_MIN_DELAY) end, Results}, State),
	ok.	

privmsg_long_results(State, Nick, [""]) ->
	cmd({privmsg, [Nick, "--"]}, State);
privmsg_long_results(State, Nick, Results) ->
	lists:foreach(fun (S) -> cmd({privmsg, [Nick, S]), timer:sleep(?PRIVMSG_MIN_DELAY) end, Results}, State),
	ok.

do_bash(State, Num) ->
	BashCmd = lists:flatten(io_lib:format("~s '~b'", ["bash.pl", Num])),
	{ok, Results} = regexp:split(yadbot_util:system(?SCRIPT_DIR, BashCmd), "\n"),
	print_long_results(State, Results).

do_bash_search(State, SearchQuery) ->
	BashCmd = lists:flatten(io_lib:format("~s '~s'", ["bash-search.pl", sanitize(SearchQuery, $')])),  %'
	{ok, Results} = regexp:split(yadbot_util:system(?SCRIPT_DIR, BashCmd), "\n"),
	print_long_results(State, Results).

do_google(State, SearchQuery) ->
	GoogleCmd = lists:flatten(io_lib:format("~s '~s'", ["google.pl", sanitize(SearchQuery, $')])),  %'
	{ok, Results} = regexp:split(yadbot_util:system(?SCRIPT_DIR, GoogleCmd), "\n"),
	print_long_results(State, Results).

do_gcalc(State, SearchQuery) ->
	GoogleCmd = lists:flatten(io_lib:format("~s '~s'", ["gcalc.pl", sanitize(SearchQuery, $')])),  %'
	{ok, Results} = regexp:split(yadbot_util:system(?SCRIPT_DIR, GoogleCmd), "\n"),
	print_long_results(State, Results).

do_wiki(State, Lang, SearchQuery) ->
	WikiCmd = lists:flatten(io_lib:format("~s ~s '~s'", ["wiki.pl", Lang, sanitize(SearchQuery, $')])),  %'
	{ok, Results} = regexp:split(yadbot_util:system(?SCRIPT_DIR, WikiCmd), "\n"),
	print_long_results(State, Results).

do_lurkmore(State, Word) ->
	Url = "http://lurkmore.ru/" ++ yadbot_util:uri_encode(Word),
	cmd({me, ["доставил: " ++ Url]}, State).

do_jbofihe(State, Sentence) ->
	FiheCmd = lists:flatten(io_lib:format("echo \"~s\" | jbofihe -x", [sanitize(Sentence, $")])),  %"
	{ok, Results} = regexp:split(yadbot_util:system(FiheCmd), "\n"),
	print_long_results(State, Results).
	
do_cmafihe(State, Sentence) ->
	FiheCmd = lists:flatten(io_lib:format("echo \"~s\" | cmafihe", [sanitize(Sentence, $")])),  %"
	{ok, Results} = regexp:split(yadbot_util:system(FiheCmd), "\n"),
	print_long_results(State, Results).

do_jvocuhadju(State, Sentence) ->
	FiheCmd = lists:flatten(io_lib:format("jvocuhadju ~s", [sanitize(Sentence, $;)])),
	{ok, Results} = regexp:split(yadbot_util:system(FiheCmd), "\n"),
	print_long_results(State, Results).
	
do_dict(State, Server, Db, Word) ->
	DictCmd = lists:flatten(io_lib:format("~s -h '~s' -d '~s' \"~s\"", ["dict.rb", Server, Db, sanitize(Word, $")])),  %"
	{ok, Results} = regexp:split(yadbot_util:system(DictCmd), "\n"),
	print_long_results(State, Results).

do_gdict(State, LangPair, Word) ->
	GdictCmd = lists:flatten(io_lib:format("~s \"~s\" '~s'", ["gdict.pl", sanitize(Word, $"), LangPair])),  %"
	{ok, Results} = regexp:split(yadbot_util:system(?SCRIPT_DIR, GdictCmd), "\n"),
	print_long_results(State, Results).

-define(LYNCH_FILE, "data/lynch.txt").

do_lynch(State, Action) ->
	{ok, Data} = file:read_file(?LYNCH_FILE),
	{ok, Lines} = regexp:split(binary_to_list(Data), "\n"),
	LineNo = random_p:uniform(length(Lines)),
	cmd({Action, [lists:nth(LineNo, Lines)]}, State),
	ok.

-define(JABBERWOCK_FILE, "data/jabberwock.txt").
-define(JABBERWOCK_DELAY, 3000).

do_jabberwock(State) ->
	cmd({chanmsg, ["Кхм кхм."]}, State),
	timer:sleep(?JABBERWOCK_DELAY),
	cmd({chanmsg, ["А вот ХУЙ вам, мне лениво."]}, State),
	ok.

%%	{ok, Data} = file:read_file(?JABBERWOCK_FILE),
%%	{ok, Lines} = regexp:split(binary_to_list(Data), "\n"),
%%	lists:foreach(fun (L) -> cmd({chanmsg, [L]), timer:sleep(500) end, Lines}, State),
%%	ok.

-define(DICE_TIMEOUT, 1000).

do_dice(State, Max) ->
	Res = random_p:uniform(Max),
	cmd({chanmsg, ["Кручу, верчу, наебать хочу..."]}, State),
	timer:sleep(?DICE_TIMEOUT),
	cmd({chanmsg, [integer_to_list(Res)]}, State).

show_help(State) ->	
	cmd({me, ["-- ахуенно полезный и функциональный бот."]}, State),
	cmd({me, ["умеет:"]}, State),
	cmd({chanmsg, ["Команды канала:"]}, State),
	print_long_results(State, ?CHANCMDLIST),
	cmd({chanmsg, ["Приватные команды:"]}, State),
	print_long_results(State, ?PRIVCMDLIST),
	cmd({me, ["няшка =^_^="]}, State).

stat_line(#userstat{ident = Ident, line_count = LineCount, sym_count = SymCount}) ->
	lists:flatten(io_lib:format(" ~-15s | ~6B | ~8B", [Ident, LineCount, SymCount])).

show_stat_line(State, Stat = #userstat{ident = OwnIdent}, OwnIdent) ->
	cmd({chanmsg, [stat_line(Stat) ++ " <=== YOU"]}, State);
show_stat_line(State, Stat, _) ->
	cmd({chanmsg, [stat_line(Stat)]}, State).

show_stat(State, OwnIdent) ->
	{atomic, Stats} = mnesia:sync_transaction(fun () -> show_stat_txn() end),
	cmd({chanmsg, [" *********** User Stats ************"]}, State),
	cmd({chanmsg, [" Ident           |  Lines |  Symbols"]}, State),
	cmd({chanmsg, [" -----------------------------------"]}, State),
	lists:foreach(fun (X) -> show_stat_line(State, X, OwnIdent), timer:sleep(?MSG_MIN_DELAY) end, Stats),
	cmd({chanmsg, [" ***********************************"]}, State).

show_stat_txn() ->
	qlc:eval(qlc:sort(qlc:q([X || X <- mnesia:table(userstat)]), {order, fun (U1, U2) -> U1#userstat.line_count > U2#userstat.line_count end})).

show_history(State, User) ->
	H = list_history(State#state.history, User#user.ident, []),
	HL = lists:filter(fun (X) -> length(X) > 0 end, H),
	privmsg_long_results(State, User#user.nick, HL),
	cmd({privmsg, [User#user.nick, "---------------------------"]}, State).

list_history([{_, quit, [#user{ident = MyIdent}, _]} | _] = H, Ident, Hist) when MyIdent == Ident ->
	list_history_tail(lists:sublist(H, ?HIST_TAIL), Hist);
list_history([{_, part, [#user{ident = MyIdent}, _]} | _] = H, Ident, Hist) when MyIdent == Ident ->
	list_history_tail(lists:sublist(H, ?HIST_TAIL), Hist);
list_history([HistEnt | Tail], Ident, Hist) ->
	io:format("Adding histent: ~s~n", [histent_to_list(HistEnt)]),
	list_history(Tail, Ident, [histent_to_list(HistEnt) | Hist]);
list_history([], _, Hist) ->
	Hist.

list_history_tail([HistEnt | Tail], Hist) ->
	io:format("Adding histent: ~s~n", [histent_to_list(HistEnt)]),
	list_history_tail(Tail, [histent_to_list(HistEnt) | Hist]);
list_history_tail([], Hist) ->
	Hist.

histent_to_list({Time, Event, Params}) ->
	{_, {HH, MM, _SS}} = Time,
	case histent_to_list({Event, Params}) of
		[] ->
			[];
		X ->
			"[" ++ integer_to_list(HH) ++ ":" ++ integer_to_list(MM) ++ "] " ++ X
	end;

histent_to_list({chanmsg, [User, Msg]}) ->
	User#user.nick ++ ": " ++ Msg;
histent_to_list({me, [User, Msg]}) ->
	"* " ++ User#user.nick ++ " " ++ Msg;
histent_to_list({nick, [User, Nick]}) ->
	User#user.nick ++ " -> " ++ Nick;	
histent_to_list({topic, [User, Topic]}) ->
	User#user.nick ++ " TOPIC: " ++ Topic;
histent_to_list({join, [User]}) ->
	"===> " ++ User#user.nick;
histent_to_list({quit, [User, Reason]}) ->
	"<=== " ++ User#user.nick ++ " ("  ++ Reason ++ ")";
histent_to_list({part, [User, Reason]}) ->
	"<=== " ++ User#user.nick ++ " ("  ++ Reason ++ ")";
histent_to_list({kick, [Kicker, Nick, Reason]}) ->
	Kicker#user.nick ++ " KICK " ++ Nick ++ " ("  ++ Reason ++ ")";
histent_to_list(_) ->
	[].

do_suicide(State, Nick, Delay) when (Delay < ?RECONN_MAX_TIMEOUT) and (Delay >= 0) ->
	cmd({kick, [State#state.nick, suicide_msg(Nick, random_p:uniform())]}, State),
	{ok, State#state{reconn_delay = Delay}};
do_suicide(State, Nick, _) ->
	cmd({chanmsg, [Nick ++ ": да хуй тебе."]}, State).

do_suicide(State, Nick) ->
	do_suicide(State, Nick, ?SUICIDE_TIMEOUT).

suicide_msg(_, X) when X < 0.4 -> "Прощай, жестокий мир.";
suicide_msg(Nick, X) when X < 0.8 -> "Сука ты, " ++ Nick ++ "!";
suicide_msg(_, _) -> "И ты, Брут :(".

suicide_greeting(State, Kicker) when State#state.nick == Kicker -> 
	suicide_self_greeting(State, random_p:uniform());
suicide_greeting(_, Kicker) -> ["Ты мудак, " ++ Kicker].

suicide_self_greeting(State, X) when X < 0.5 ->
	["Ты суицидальный мудак, " ++ State#state.nick];
suicide_self_greeting(_, _) ->
	["Мафия говорила, что она бессмертна..."].

update_stat(User, Msg) ->
	mnesia:sync_transaction(fun () -> update_stat_txn(User, Msg) end).

update_stat_txn(#user{ident = Ident}, Msg) ->
	case mnesia:read({userstat, Ident}) of
		[] ->
			io:format("New stat~n"),
			ok = mnesia:write(#userstat{ident = Ident, sym_count = length(Msg)});
		[Stat] ->
			io:format("Update stat~n"),
			ok = mnesia:write(Stat#userstat{line_count = Stat#userstat.line_count + 1,
											sym_count = Stat#userstat.sym_count + length(Msg)});
		Any ->
			io:format("WARN: ~p", [Any])
	end.

strip_linefeeds([$\r | Tail]) ->
	strip_linefeeds(Tail);
strip_linefeeds([$\n | Tail]) ->
	strip_linefeeds(Tail);
strip_linefeeds([Char | Tail]) ->
	[Char | strip_linefeeds(Tail) ];
strip_linefeeds([]) ->
	[].

sanitize(String, $") ->
	{ok, Res, _} = regexp:gsub(String, "\\\"", "'"),
	Res;
sanitize(String, $') ->
	{ok, Res, _} = regexp:gsub(String, "\\'", "\""),
	Res;
sanitize(String, $;) ->
	{ok, Res, _} = regexp:gsub(String, ";", ""),
	{ok, Res2, _} = regexp:gsub(Res, "&", ""),
	{ok, Res3, _} = regexp:gsub(Res2, "|", ""),
	{ok, Res4, _} = regexp:gsub(Res3, ">", ""),
	{ok, Res5, _} = regexp:gsub(Res4, "<", ""),
	{ok, Res6, _} = regexp:gsub(Res5, "\\(", ""),
	{ok, Res7, _} = regexp:gsub(Res6, "\\)", ""),
	{ok, Res8, _} = regexp:gsub(Res7, "'", "\\'"),
	{ok, Res9, _} = regexp:gsub(Res8, "\"", "\\\""),
	Res9.

