-module(irc_proto).
-author("Ivan Korotkov <twee@tweedle-dee.org>").

%%% gen_server
-behaviour(gen_server).
-export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).

%%% public interface
-export([start_link/0, connect/0, send_irc_command/2]).

%% @type irc_event() = {Type, Originator} | {Type, Originator, Arg1} | {Type, Originator, Arg1, Arg2} | etc
%%              Type = atom()
%%        Originator = list() | 'undefined'.
%% Type is atom describing event type (chanmsg, topic, etc), Originator is either channel name (when event belongs to channel), 
%% user name (when event is associated with some user, like quitting, changing nick, privmsg) or 
%% `undefined' if event is a server event.
%% *Any* event must have a valid Originator (including events generated by behaviours which generally 
%% should have the same originator as the original event).

%% -record(conf, {ping_timeout  = 90000,
%% 			   sock_timeout  = 60000,
%% 			   port          = 6667,
%% 			   maxsend       = 450}).

-record(state, {host             :: list(),
				owner            :: pid(),
				sock = undefined :: port(),
				ping             :: integer(),
				maxsend          :: integer()}).

-compile([bin_opt_info]).

%%% API

start_link() ->
	gen_server:start_link({local, ?MODULE}, ?MODULE, self(), []).

%% Initiate connection
connect() ->
	gen_server:cast(?MODULE, connect).

%% Send IRC command (low-level)
send_irc_command(IrcRef, Cmd) ->
	gen_server:cast(IrcRef, {irc_command, Cmd}).

%%% gen_server callbacks

%% real connect is deferred 
init(Owner) ->
	{ok, Host}    = application:get_env(host),
	{ok, Ping}    = application:get_env(ping_timeout),
	{ok, MaxSend} = application:get_env(maxsend),
	{ok, #state{owner = Owner, host = Host, ping = Ping, maxsend = MaxSend}}.

handle_call(_Req, _From, State) ->
	{reply, unknown_call, State, State#state.ping}.

handle_cast({irc_command, Cmd}, State) ->
	{noreply, do_command(Cmd, State), State#state.ping};
handle_cast(connect, State) ->
	{ok, NewState} = do_connect(State),
	{noreply, NewState, NewState#state.ping};
handle_cast(_Req, State) ->
	{noreply, State, State#state.ping}.

%% EXIT signal is not handled and will terminate
handle_info(timeout, State) ->
	{stop, timeout, State};
handle_info({tcp_closed, Sock}, State) when Sock == State#state.sock ->
	{stop, tcp_closed, State};
handle_info({tcp_error, Sock, Reason}, State) when Sock == State#state.sock ->
	{stop, {tcp_error, Reason}, State};
handle_info({tcp, Sock, Data}, State) when Sock == State#state.sock ->
	{Event, NewState} = parse_line(utf8:decode(Data), State),
	{noreply, notify(Event, NewState), NewState#state.ping};
handle_info(_Info, State) ->
	{noreply, State, State#state.ping}.

terminate(_Reason, #state{sock = Sock}) ->
	gen_tcp:close(Sock).

code_change(_Vsn, State, _Extra) ->
	{ok, State}.

%%% Internal functions

do_connect(#state{host = Host} = State) ->
	error_logger:info_report([{connecting, Host}]),
	conn_throttle(State),
	{ok, Port}        = application:get_env(port),
	{ok, SockTimeout} = application:get_env(sock_timeout),
	case gen_tcp:connect(Host, Port, 
						 [binary,
						  {packet, line},
						  {send_timeout, SockTimeout},
						  {send_timeout_close, true}], 
						 SockTimeout) of
		{ok, Sock} ->
			{ok, State#state{sock = Sock}};
		{error, timeout} ->
			error_logger:warning_report([{connect_error, timeout}]),
			do_connect(State);
		{error, Error} ->
			error_logger:error_report([{connect_error, Error}]),
			{error, Error}
	end.

conn_throttle(#state{host = Host}) ->
	{ok, {MaxConn, Period}} = application:get_env(conn_rate),
	throttle:wait(Host, MaxConn, Period,
				  fun (Delay) ->
						  error_logger:warning_report([{throttled, Delay}]),
						  Delay
				  end).

notify(Event, #state{owner = Pid} = State) ->
	Pid ! {irc, self(), Event},
	State.

%% Actually, this code and EXIT trapping are not neccessary as TCP socket is closed when controlling process dies

%%% IRC protocol commands

%% Here, chanmsg and privmsg join back again
do_command({chanmsg, Channel, Msg}, State)       -> do_command({privmsg, Channel, Msg}, State);
do_command({privmsg, To, Msg}, State)            -> send(State, "PRIVMSG " ++ To ++ " :", Msg);
do_command({join, Channel}, State)               -> send(State, "JOIN :" ++ Channel);
do_command({part, Channel}, State)               -> send(State, "PART " ++ Channel);
do_command({quit, QuitMsg}, State)               -> send(State, "QUIT :" ++ QuitMsg);
do_command({action, Channel, Action}, State)     -> send(State, "PRIVMSG " ++ Channel ++ " :" ++ [1] ++ "ACTION ", Action, [1]);
do_command({mode, Channel, User, Mode}, State)   -> send(State, "MODE " ++ Channel ++ " " ++ Mode ++ " " ++ User);
do_command({umode, User, Mode}, State)           -> send(State, "MODE " ++ User ++ " " ++ Mode);
do_command({user, Login, LongName}, State)       -> send(State, "USER " ++ Login ++ " 8 * :" ++ LongName);
do_command({nick, Nick}, State)                  -> send(State, "NICK " ++ Nick);
do_command({oper, Login, Passwd}, State)         -> send(State, "OPER " ++ Login ++ " " ++ Passwd);
do_command({kick, Channel, Nick, Reason}, State) -> send(State, "KICK " ++ Channel ++ " " ++ Nick ++ " :" ++ Reason);
do_command({topic, Channel, Topic}, State)       -> send(State, "TOPIC " ++ Channel ++ " :" ++ Topic);
do_command({pong, Server}, State)                -> send(State, "PONG :" ++ Server).

%% Send raw command
%% Raw command consists of:
%% - prefix
%% - text line (may be broken into several lines)
%% - suffix
%% In case total line is too long, it gets broken into several lines with same prefix/suffix
send(State, Prefix) -> send(State, Prefix, [], []).

send(State, Prefix, Line) -> send(State, Prefix, Line, []).

send(State, Prefix, Line, Suffix) -> 
	send_bytes(State, utf8:encode(Prefix), utf8:encode(Line), utf8:encode(Suffix)).

-define(CRLF, "\r\n").

-define(PACKET_SIZE(Prefix, Data, Suffix), 
		(size(Prefix) + size(Data) + size(Suffix) + size(<<?CRLF>>))).

%% Splits raw lines in chunks of no more than `maxsend' bytes
%% BUG: maxsend is actually greater (512) but then own identname (nick!ident@host) must be taken into account
%% We don't handle this for now (bug #46)
send_bytes(State, Prefix, Bytes, Suffix) when ?PACKET_SIZE(Prefix, Bytes, Suffix) =< State#state.maxsend ->
	true = sanity_check(Bytes),
	ok = gen_tcp:send(State#state.sock, <<Prefix/binary, Bytes/binary, Suffix/binary, ?CRLF>>),
	State;
send_bytes(State, Prefix, Bytes, Suffix) ->
	{ByteLine, Rest} = utf8:split(Bytes, State#state.maxsend - ?PACKET_SIZE(Prefix, <<>>, Suffix)),
	S = send_bytes(State, Prefix, ByteLine, Suffix),
	send_bytes(S, Prefix, Rest, Suffix).

%% Ensure buffer has no CRLF and null bytes
sanity_check(<<C/utf8, Rest/binary>>) ->
	case C of
		$\r -> false;
		$\n -> false;
		0   -> false;
		_   ->
			sanity_check(Rest)
	end;
sanity_check(<<>>) ->
	true.

%%% IRC protocol parser

chop(Line) ->
	string:left(Line, string:len(Line) - 2).

%% Parses raw IRC line, returns {Event, NewState}
parse_line(Line, State) ->
	%% BUG Doesn't parse ISUPPORT correctly
	case re:run(Line, "^:?([^:]+):(.*)" ++ ?CRLF, [unicode, {capture, all_but_first, list}]) of
		nomatch ->
			Header = string:strip(chop(Line), left, $:),
			Headers = string:tokens(Header, " "),
			parse_special(Headers, State);
		{match, [Header, Text]} ->
			Headers = string:tokens(Header, " "),
			parse_special(Headers ++ [Text], State)
	end.

%% Detect special cases (ping, error)
parse_special(["ERROR", Error], State) -> {{error, undefined, Error}, State};
parse_special(["PING", Server], State) -> {{ping, undefined, Server}, State};
parse_special(Tokens, State)           -> parse_user(Tokens, State).

%% Parse identline (nick!ident@host)
parse_user([MaybeLogin | Rest], State) ->
	case re:run(MaybeLogin, "(.*)!(.*)@(.*)", [unicode, {capture, all_but_first, list}]) of
		{match, [Nick, Ident, Host]} ->
			User = {Nick, Ident, Host},
			parse_code([User | Rest], State);
		nomatch ->
			parse_code([MaybeLogin | Rest], State)
	end.

-define(IS_DIGIT(Var), $0 =< Var, Var =< $9).

%% Parse error code, if present
parse_code([Target, [D1, D2, D3] | Rest], State) when ?IS_DIGIT(D1), ?IS_DIGIT(D2), ?IS_DIGIT(D3) ->
	parse_tokens([Target, irc_codes:code_to_atom([D1, D2, D3]) | Rest], State);
parse_code(Tokens, State) ->
	parse_tokens(Tokens, State).

%% Final parsing
parse_tokens([User, "PRIVMSG", Target, Msg], State) ->
	parse_privmsg(Target, User, Msg, State);
parse_tokens([User, "TOPIC", Channel, Topic], State) ->
	{{topic, Channel, User, Topic}, State};
parse_tokens([User, "NICK", NewNick], State) ->
	{{nick, NewNick, User}, State};
parse_tokens([User, "JOIN", Channel], State) ->
	{{join, Channel, User}, State};
parse_tokens([User, "PART", Channel, Reason], State) ->
	{{part, Channel, User, Reason}, State};
parse_tokens([User, "PART", Channel], State) ->
	{{part, Channel, User, []}, State};
parse_tokens([User, "QUIT", Reason], State) ->
	{{quit, User, Reason}, State};
parse_tokens([User, "KICK", Channel, Nick, Reason], State) ->
	{{kick, Channel, User, Nick, Reason}, State};
parse_tokens([Nick, "MODE", Nick, Mode], State) ->
	{{umode, Nick, Mode}, State};
parse_tokens([User, "MODE", Channel, Mode, Nick], State) ->
	{{mode, Channel, User, Mode, Nick}, State};
parse_tokens([_Server, "NOTICE", _Target, Notice], State) ->
	{{notice, undefined, Notice}, State};
parse_tokens([_Server, topic, _Target, Channel, Topic], State) ->
	{{chantopic, Channel, Topic}, State};
parse_tokens([_Server, topicinfo, _Target, Channel, Author, Ts], State) ->
	{{chantopic, Channel, Author, list_to_integer(Ts)}, State};
parse_tokens([_Server, namreply, _Target, _, Channel, Users], State) ->
	{{names, Channel, parse_names(Users)}, State};
parse_tokens([_Server, myinfo, _Target, Server, Vsn, Umodes, Chanmodes | _], State) ->
	{{myinfo, undefined, Server, Vsn, Umodes, Chanmodes}, State};
parse_tokens([_Server, Reply, _Target, Channel, Text], State)
  when Reply =:= inviteonlychan; Reply =:= bannedfromchan; Reply =:= badchannelkey; Reply =:= badchanmask; 
	   Reply =:= nosuchchannel; Reply =:= channelisfull; Reply =:= toomanychannels; Reply =:= killdeny;
	   Reply =:= endofnames ->
	{{Reply, Channel, Text}, State};
parse_tokens([_Server, Reply, _Target, Nick, Text], State) when is_atom(Reply) ->
	{{Reply, Nick, Text}, State};
parse_tokens([_Server, Reply, _Target, Text], State) when is_atom(Reply) ->
	{{Reply, undefined, Text}, State};
parse_tokens([_Server, Reply, _Target | Text], State) when is_atom(Reply) ->
	{{Reply, undefined, Text}, State};
parse_tokens(Tokens, State) ->
	{{unknown, undefined, Tokens}, State}.

%% Privmsg actually may be one of:
%% - `action' (detected here)
%% - `chanmsg'
%% - `privmsg' (this is distinguished from `chanmsg' on higher level, where own nick is known)
parse_privmsg(Channel, User, [1] ++ "ACTION " ++ Action, State) ->
	{{action, Channel, User, string:strip(Action, right, 1)}, State};
parse_privmsg(Target, User, Msg, State) ->
	{{privmsg, Target, User, Msg}, State}.

%% Parse `namesreply' (user list on channel)
parse_names(Names) ->
	[parse_name(Token) || Token <- string:tokens(Names, " ")].

parse_name([$* | Name]) ->
	{op, Name, [owner]};
parse_name([$@ | Name]) ->
	{op, Name, []};
parse_name([$+ | Name]) ->
	{user, Name, [voice]};
parse_name(Name) ->
	{user, Name, []}.
